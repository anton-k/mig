<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JSON application: weather forecast - Mig by example</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00-foreword.html">Foreword</a></li><li class="chapter-item expanded "><a href="01-hello-world.html"><strong aria-hidden="true">1.</strong> Hello world example</a></li><li class="chapter-item expanded "><a href="02-request-anatomy.html"><strong aria-hidden="true">2.</strong> Anatomy of the request</a></li><li class="chapter-item expanded "><a href="03-response-anatomy.html"><strong aria-hidden="true">3.</strong> Anatomy of the response</a></li><li class="chapter-item expanded "><a href="04-other-monads.html"><strong aria-hidden="true">4.</strong> Using other monads</a></li><li class="chapter-item expanded "><a href="05-plugin.html"><strong aria-hidden="true">5.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="06-swagger.html"><strong aria-hidden="true">6.</strong> Using Swagger</a></li><li class="chapter-item expanded "><a href="06-json-api-example.html" class="active"><strong aria-hidden="true">7.</strong> JSON application: weather forecast</a></li><li class="chapter-item expanded "><a href="07-blog-post-example.html"><strong aria-hidden="true">8.</strong> HTML example: blog site</a></li><li class="chapter-item expanded "><a href="08-reference.html"><strong aria-hidden="true">9.</strong> Reference</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Mig by example</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="json-example-weather-forecast"><a class="header" href="#json-example-weather-forecast">JSON example: weather forecast</a></h1>
<p>We have learned all we need to know about <code>mig</code> to be able to build something cool with it.
Let's build a weather forecast application. The app has registered users
which can request authroization tokens. With that token users can request for weather
in specific city and on specific time and also they can update the weather data.
For simplicity we omit user registration and defining roles for the user.</p>
<h2 id="domain-for-our-application"><a class="header" href="#domain-for-our-application">Domain for our application</a></h2>
<p>Let's define main types for our application in the module <code>Types.hs</code>.
We will import <code>Mig.Json.IO</code> to bring in scope some classes and types
common for HTTP-servers:</p>
<pre><code class="language-haskell">module Types where

import Data.Time (Day)
import Mig.Json.IO
</code></pre>
<h3 id="domain-of-users"><a class="header" href="#domain-of-users">Domain of users</a></h3>
<p>There are users in the application that can register and get session tokens:</p>
<pre><code class="language-haskell">data User = User
  { name :: Text
  , pass :: Text
  }
  deriving (Generic, ToJSON, FromJSON, ToSchema)

newtype AuthToken = AuthToken Text
  deriving newtype 
    (ToJSON, FromJSON, FromHttpApiData, Eq, Ord, Show, ToParamSchema, ToSchema)
</code></pre>
<p>We need instances to pass the dat over HTTP wires.</p>
<h3 id="domain-of-weather"><a class="header" href="#domain-of-weather">Domain of weather</a></h3>
<p>We are going to query weather info by location and date:</p>
<pre><code class="language-haskell">newtype DayInterval = DayInterval Int
  deriving newtype (ToJSON, FromJSON, FromHttpApiData, ToParamSchema)

data Timed a = Timed
  { from :: Day
  , content :: [a]
  }
  deriving (Generic, ToJSON, FromJSON)

deriving instance (ToSchema a) =&gt; ToSchema (Timed a)

newtype Location = Location Text
  deriving newtype 
    (ToJSON, FromJSON, FromHttpApiData, Eq, Ord, Show, ToParamSchema, ToSchema)
</code></pre>
<p>The weather has information on temperature, speed of the wind, sun/rain nratio and pressure:</p>
<pre><code class="language-haskell">data WeatherData = WeatherData
  { temperature :: Int
  , windSpeed :: Int
  , sunRainRatio :: Int
  , pressure :: Int
  }
  deriving (Generic, ToJSON, FromJSON, ToSchema)
</code></pre>
<p>Also some users can update DB of weather:</p>
<pre><code class="language-haskell">-- | Update weather data
data UpdateData = UpdateData
  { day :: Day
  , location :: Location
  , content :: WeatherData
  }
  deriving (Generic, ToJSON, FromJSON, ToSchema)
</code></pre>
<p>That is our domain for the weather application.</p>
<h2 id="lets-define-a-server"><a class="header" href="#lets-define-a-server">Lets define a server</a></h2>
<p>We are going to build JSON HTTP application. For that we will use module <code>Mig.Json.IO</code>
which provides handy types specified to our domain.
We expect our application to have shared context <code>Env</code> which we pass to all handlers.</p>
<pre><code class="language-haskell">import Mig.Json.IO
import Types

server :: Env -&gt; Server IO
server env =
  withSwagger def $
    &quot;api/v1/weather&quot;
      /. [ auth
         , withAuth env $: app
         ]
  where
    auth = &quot;get/auth-token&quot; /. requestAuthToken env

    app =
      mconcat
        [ &quot;get/weather&quot; /. getWeather env
        , &quot;update&quot; /. updateWeather env
        ]

-- | Site internal shared context
data Env = Env

-- weather

getWeather ::
  Env -&gt;
  Capture &quot;location&quot; Location -&gt;
  Capture &quot;day&quot; Day -&gt;
  Capture &quot;day-interval&quot; DayInterval -&gt;
  Get (RespOr Text (Timed WeatherData))
getWeather = undefined

updateWeather ::
  Env -&gt;
  Body UpdateData -&gt;
  Post (RespOr Text ())
updateWeather = undefined

-- users

requestAuthToken :: Env -&gt; Body User -&gt; Post (RespOr Text AuthToken)
requestAuthToken = undefined

withAuth :: Env -&gt; Header &quot;auth&quot; AuthToken -&gt; Plugin IO
withAuth = undefined
</code></pre>
<p>we have one route to query for token:</p>
<pre><code class="language-haskell">requestAuthToken :: Env -&gt; Body User -&gt; Post (RespOr Text AuthToken)
</code></pre>
<p>and two routes that query info on weather and update it:</p>
<pre><code class="language-haskell">getWeather ::
  Env -&gt;
  Capture &quot;location&quot; Location -&gt;
  Capture &quot;day&quot; Day -&gt;
  Capture &quot;day-interval&quot; DayInterval -&gt;
  Get (RespOr Text (Timed WeatherData))

updateWeather ::
  Env -&gt;
  Body UpdateData -&gt;
  Post (RespOr Text ())
</code></pre>
<p>also we have a plugin that filters out non aunthorized calls:</p>
<pre><code class="language-haskell">withAuth :: Env -&gt; Header &quot;auth&quot; AuthToken -&gt; Plugin IO
</code></pre>
<p>From its type-signature we can assume that authroization token
is passed in the header of the request.</p>
<h2 id="the-structure-of-the-server"><a class="header" href="#the-structure-of-the-server">The structure of the server</a></h2>
<p>We define server as a collection of actions that can be performed. 
The server is defined in terms of interfaces. We can initialize those interfaces
and pass them to handlers. </p>
<p>Our app has several domains:</p>
<ul>
<li>
<p>users and sessions</p>
</li>
<li>
<p>weather DB interface</p>
</li>
<li>
<p>process lifecycle: logging, startup, cleanup, etc</p>
</li>
</ul>
<p>So the server enironment has three parts:</p>
<pre><code class="language-haskell">data Env = Env
  { auth :: Auth
  , weather :: Weather
  , proc :: Proc
  }
</code></pre>
<p>Let's define operations for those domains. We define them in the module <code>Interface.hs</code>.</p>
<h3 id="user-domain"><a class="header" href="#user-domain">User domain</a></h3>
<p>For the user we can do</p>
<ul>
<li>
<p>check that user is valid and can use the app</p>
</li>
<li>
<p>allocate new authorization token</p>
</li>
<li>
<p>check that token is valid</p>
</li>
<li>
<p>expire the token (make it invalid)</p>
</li>
</ul>
<pre><code class="language-haskell">-- authorization interface
data Auth = Auth
  { newToken :: User -&gt; IO AuthToken
  , validUser :: User -&gt; IO Bool
  , validToken :: AuthToken -&gt; IO Bool
  , expireToken :: AuthToken -&gt; IO ()
  }
</code></pre>
<h3 id="weather-domain"><a class="header" href="#weather-domain">Weather domain</a></h3>
<p>For the weather we can query info and update it:</p>
<pre><code class="language-haskell">-- weather forecast interface
data Weather = Weather
  { get :: Location -&gt; Day -&gt; DayInterval -&gt; IO (Maybe (Timed WeatherData))
  , update :: UpdateData -&gt; IO ()
  }
</code></pre>
<h3 id="process-domain"><a class="header" href="#process-domain">Process domain</a></h3>
<p>For the application process we keep all server lifecycle tools
which are not related to business logic domain. It can be logging, metrics,
startup and cleanup actions:</p>
<pre><code class="language-haskell">-- | Process interface
data Proc = Proc
  { startup :: IO ()
  , cleanup :: IO ()
  , Logger :: Logger
  }

-- logger interface
data Logger = Logger
  { info :: LogFun
  , debug :: LogFun
  , error :: LogFun
  }

type LogFun = Value -&gt; IO ()
</code></pre>
<p>We log JSON-values. As a helper functions we create funcitions
that can log anything which is convertible to JSON:</p>
<pre><code class="language-haskell">logInfo :: (ToJSON a) =&gt; Env -&gt; a -&gt; IO ()
logInfo env = env.proc.logger.info . toJSON

logDebug :: (ToJSON a) =&gt; Env -&gt; a -&gt; IO ()
logDebug env = env.proc.logger.debug . toJSON

logError :: (ToJSON a) =&gt; Env -&gt; a -&gt; IO ()
logError env = env.proc.logger.error . toJSON
</code></pre>
<h3 id="using-interfacs"><a class="header" href="#using-interfacs">Using interfacs</a></h3>
<p>It's interesting to note how all actions on shared state can be expressed
as interfaces. We will declare the concrete mutable representation later
but for now it is ok to hide them with not implemented yet functions.
This also allows us to create mock applications for testing and substitute
implementations without changing the code for the server.</p>
<h2 id="define-server-in-terms-of-interfaces"><a class="header" href="#define-server-in-terms-of-interfaces">Define server in terms of interfaces</a></h2>
<p>As we have defined the main operations of the application we can complete 
the definition of the server.
Let's define the routes for weather domain first as they are more simple.</p>
<h3 id="weather-domain-1"><a class="header" href="#weather-domain-1">Weather domain</a></h3>
<p>We can query the weather forecast with function:</p>
<pre><code class="language-haskell">getWeather ::
  Env -&gt;
  Capture &quot;location&quot; Location -&gt;
  Capture &quot;day&quot; Day -&gt;
  Capture &quot;day-interval&quot; DayInterval -&gt;
  Get (RespOr Text (Timed WeatherData))
getWeather env (Capture location) (Capture fromDay) (Capture interval) = Send $ do
  logInfo @Text env &quot;get the weather forecast&quot;
  mResult &lt;- env.weather.get location fromDay interval
  pure $ case mResult of
    Just result -&gt; ok result
    Nothing -&gt; bad status400 &quot;No data&quot;
</code></pre>
<p>We log that call to get weather is in the progress.
Then we try to fetch weather data and if it has the data
we return it to the user otherwise we report error.</p>
<p>Let's update the weather data:</p>
<pre><code class="language-haskell">updateWeather ::
  Env -&gt;
  Body UpdateData -&gt;
  Post (Resp ())
updateWeather env (Body updateData) = Send $ do
  logInfo @Text env &quot;update the weather data&quot;
  ok &lt;$&gt; env.weather.update updateData
</code></pre>
<p>we log the report and update the weather data.</p>
<h3 id="the-user-domain"><a class="header" href="#the-user-domain">The user domain</a></h3>
<p>Let's give the user access token and check that token is valid.
Let's allocate a new token in the hanlder <code>requestAuthToken</code>:</p>
<pre><code class="language-haskell">requestAuthToken :: Env -&gt; Body User -&gt; Post (RespOr Text AuthToken)
requestAuthToken env (Body user) = Send $ do
  logInfo env (&quot;get new auth token for: &quot; &lt;&gt; user.name)
  isValid &lt;- env.auth.validUser user
  if isValid
    then do
      token &lt;- env.auth.newToken user
      void $ forkIO $ setExpireTimer token
      pure $ ok token
    else do
      logError env $ Text.unwords [&quot;User&quot;, user.name, &quot;does not have access to the service&quot;]
      pure $ bad unauthorized401 &quot;User is not valid&quot;
  where
    setExpireTimer :: AuthToken -&gt; IO ()
    setExpireTimer token = do
      threadDelay (1_000_000 * 60 * 10) -- 10 minutes
      env.auth.expireToken token
</code></pre>
<p>We check that user is valid and if the user is valid
we give user a token and also set the expiration for it. 
We will expire it 10 minutes after registration.
The expiration is concurrent process that is forked from the thread 
that hnadles the request. If user has no rights to use our service we report error.</p>
<p>Let's check for authorization tokens. Ideally we would like to add
this action to all handlers of our application. We would like to keep
the business logic handlers for the weather domain the same.
And we can do it with plugin. Let's define such a plugin
that expects authorization tokens with required header:</p>
<pre><code class="language-haskell">withAuth :: Env -&gt; Header &quot;auth&quot; AuthToken -&gt; Plugin IO
withAuth env (Header token) = processResponse $ \getResp -&gt; do
  isOk &lt;- env.auth.validToken token
  if isOk
    then getResp
    else do
      logError env errMessage
      pure $ Just (bad status500 $ Text.encodeUtf8 errMessage)
  where
    errMessage = &quot;Token is invalid&quot;
</code></pre>
<p>we have covered in depth how to implement it in the chapter on Plugins
so this code should look familiar to us.</p>
<h3 id="run-application"><a class="header" href="#run-application">Run application</a></h3>
<p>That completes the definition of the server. Let's run it. We define the main function
in the module <code>Main.hs</code>:</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  env &lt;- initEnv port
  env.proc.startup
  runServer port (server env)
    `finally` env.proc.cleanup
  where
    port = 8085

initEnv :: Port -&gt; IO Env
initEnv = undefined
</code></pre>
<p>The initialization of interfaces is yet to be defined.
So this is all we need to start the server.</p>
<h2 id="implementation-of-the-interfaces"><a class="header" href="#implementation-of-the-interfaces">Implementation of the interfaces</a></h2>
<p>For the purpose of the example we will create a mock application.
A bit more detailed implementation is in the source code of the <code>mig</code> library.
See example <code>JsonApi</code>.</p>
<h2 id="mock-application"><a class="header" href="#mock-application">Mock application</a></h2>
<p>We can create a mock application with one user.</p>
<pre><code class="language-haskell">import Data.ByteString.Char8 qualified as B
import Data.Yaml qualified as Yaml
import Data.Aeson qualified as Json

initEnv :: Port -&gt; IO Env
initEnv port = pure $ Env initAuth initWeather (initProc proc)

-- | Application with single user john with token that never expires
initAuth :: Auth
initAuth = 
  Auth
  { newToken = const $ pure AuthToken &quot;john-token&quot;
  , validUser = \(User name pass) = pure $ name == &quot;john&quot; &amp;&amp; pass == &quot;123&quot;
  , validToken = (\AuthToken token) -&gt; pure (token == &quot;john-token&quot;)
  , expireToken = const $ pure ()
  }

initWeather = Weather
  { get = \location day dayInterval -&gt; pure Nothing
  , update = \updateData -&gt; pure ()
  }

initProc :: Port -&gt; Proc
initProc = 
  pure Proc 
    { logger = logger
    , startup = logger.info $ &quot;App started on port: &quot; &lt;&gt; Text.pack (show port)
    , cleanup = logger.info &quot;App shutdown&quot;
    }
  where
    logger = initLogger

initLogger :: Logger
initLogger = Logger
  { info = logBy &quot;info&quot; 
  , debug = logBy &quot;debug&quot;
  , error = logBy &quot;error&quot;
  }
  where
    logBy :: Text -&gt; Json.Value msg -&gt; IO ()
    logBy level msg = B.putStrLn . Yaml.encode . addLogPrefix $
        Json.object [ &quot;level&quot; .= level, &quot;message&quot; .= msg ]

addLogPrefix :: Json.Value -&gt; Json.Value
addLogPrefix val = Json.object [&quot;log&quot; .= val]
</code></pre>
<p>we can start the application and try it out with swagger.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>You can find the complete code of the example in the <a href="https://github.com/anton-k/mig/blob/main/examples/mig-example-apps/JsonApi"><code>mig</code> repo</a>.</p>
<ul>
<li>
<p>implement routes for user registration. Only registered users can receive the authorization token.</p>
</li>
<li>
<p>implement roles for the users:</p>
<ul>
<li>admin: can manage users</li>
<li>db-writer: can update weather forecast</li>
<li>visitor: can only view forecasts</li>
</ul>
</li>
<li>
<p>implement in-memory storage of the weather DB. Use maps to store weather data and info
on valid users and tokens.</p>
</li>
<li>
<p>implement real logger with <code>fast-logger</code> library</p>
</li>
<li>
<p>implement interface that connects application to some real DB.
The code for the server should stay the same and only initialization
of interface should change. Use one of the DB libraries for haskell: <code>hasql</code>, <code>postgresql-simple</code></p>
</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter we have defined a more substantial example of JSON HTTP application
and saw how we can apply various concepts in practice.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="06-swagger.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="07-blog-post-example.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="06-swagger.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="07-blog-post-example.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
